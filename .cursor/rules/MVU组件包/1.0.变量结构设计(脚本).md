# 模块1.0：变量结构设计（Zod脚本）

## 模块定义

本模块是 MVU 系统的第一步，负责通过 Zod schema 定义变量的结构、类型和验证规则。

**核心功能**：
- 使用 Zod 4.x 定义变量结构
- 提供类型安全和运行时验证
- 支持增量更新和幂等操作
- 为后续的变量初始化和更新提供结构约束

**重要说明**：
- 此模块在传统 MVU 初始化之前执行
- 定义的 schema 将用于验证所有变量更新操作
- 支持复杂的嵌套结构和自定义验证逻辑

---

## 生成任务

根据项目需求，使用 Zod 4.x 定义变量结构的 schema，生成完整的 JavaScript 脚本文件。

---

## Zod Schema 设计规范

### 可用的库

**重要说明**：`z`（来自 Zod）和 `_`（来自 Lodash）默认可用，可以直接使用，无需再次导入。

```js
// ✅ 正确：直接使用
好感度: z.coerce.number().transform(v => _.clamp(v, -100, 100))

// ❌ 错误：不要重复导入
import _ from 'lodash';  // 不需要
import { z } from 'zod'; // 不需要
```

---

### Zod 版本要求

**重要说明**：本项目使用 Zod 4.x 版本。

- ✅ 使用 Zod 4.x 的所有标准功能
- ❌ **禁止使用** `.passthrough()` 方法（此方法在 Zod 4.x 中不支持或行为不稳定）

```js
// ✅ 正确：使用 Zod 4.x 的标准方法
export const Schema = z.object({
  日期: z.string(),
  好感度: z.coerce.number()
});

// ❌ 错误：不要使用 .passthrough()
export const Schema = z.object({
  日期: z.string()
}).passthrough();  // 禁止使用！
```

---

### 函数类型的使用

在 Schema 定义中，某些位置支持使用函数而非直接值，以支持动态计算或延迟初始化。

#### registerMvuSchema 的函数形式

`registerMvuSchema` 支持两种输入形式：

```typescript
registerMvuSchema = (schema: z.ZodObject | (() => z.ZodObject)) => void
```

**直接传入 schema**（常规用法）：
```js
export const Schema = z.object({
  日期: z.string(),
  // ...
});

$(() => {
  registerMvuSchema(Schema);
})
```

**传入函数**（延迟计算）：
```js
$(() => {
  registerMvuSchema(() => z.object({
    日期: z.string(),
    当前时区: z.string().prefault(() => Intl.DateTimeFormat().resolvedOptions().timeZone),
    // 依赖运行时数据或函数
  }));
})
```

**使用场景**：
- Schema 依赖运行时数据或函数
- Schema 在注册时尚未完全确定
- 需要动态计算 Schema 结构

---

#### z.transform 的函数输入

`z.transform` 接受函数作为转换逻辑：

```js
z.transform(value => transformedValue)
```

**示例**：
```js
好感度: z.coerce.number().transform(value => _.clamp(value, 0, 100))
```

**注意**：函数在每次解析时执行，需确保幂等性。

---

#### z.prefault / z.catch 的函数形式

`z.prefault` 和 `z.catch` 都支持函数形式，用于动态生成默认值：

```js
z.prefault(value | (() => value))
z.catch(value | (() => value))
```

**静态值**（值在定义时确定）：
```js
物品栏: z.record(z.string(), z.object({
  描述: z.string()
})).prefault({})
```

**动态值**（每次使用时重新计算）：
```js
记忆: z.record(
  z.string().describe('记忆ID'),
  z.object({
    内容: z.string(),
    $time: z.coerce.number().prefault(() => Date.now())  // 每次插入时生成新时间戳
  })
)
```

**使用场景**：
- `() => Date.now()`：每次需要不同的时间戳
- `() => crypto.randomUUID()`：每次需要唯一标识符
- `() => []` / `() => {}`：每次需要新的对象/数组实例（避免共享引用）

**重要**：
- 静态值（如 `{}`、`[]`）会在所有地方共享同一个引用
- 使用函数形式 `() => {}` 或 `() => []` 可确保每次创建新实例
- 仅在需要动态值或避免引用共享时使用函数形式

---

### 幂等操作原则

Schema 设计必须支持增量更新，确保：
```
Schema.parse(Schema.parse(input)) === Schema.parse(input)
```

**要点**：
- 谨慎使用 `z.transform`，避免破坏幂等性
- 确保 schema 的输出可以作为自身的有效输入

---

### 类型定义规则

#### 数字类型

**优先使用** `z.coerce.number()`：
```js
// 推荐：自动转换字符串数字
好感度: z.coerce.number()

// 不推荐：无法处理字符串输入
好感度: z.number()
```

**注意**：仅对数字使用 `z.coerce.xxx()`，其他类型直接使用基础类型（如 `z.boolean()`、`z.string()`）

---

#### 对象结构优于数组

**推荐方式**（使用 record）：
```js
物品栏: z.record(
  z.string().describe('物品名'),
  z.object({
    描述: z.string(),
    数量: z.coerce.number()
  })
)
```

**不推荐**（使用 array）：
```js
物品栏: z.array(z.object({
  名称: z.string(),
  描述: z.string(),
  数量: z.coerce.number()
}))
```

**原因**：数组索引难以理解和维护，使用对象键（如物品名）更直观

---

#### 对象 Schema 的选择策略

根据对象的键特征选择合适的 schema 类型：

**1. 固定必需键 + 相同类型**
```js
z.record(
  z.enum(['key1', 'key2', ...]),
  z.string()  // 统一的值类型
)
```

**2. 固定可选键 + 相同类型**
```js
z.partialRecord(
  z.enum(['key1', 'key2', ...]),
  z.string()  // 统一的值类型
)
```

**3. 动态可选键 + 相同类型**
```js
z.record(z.string(), z.coerce.number())
```

**4. 固定必需键 + 不同类型**
```js
z.object({
  key1: z.string(),
  key2: z.coerce.number(),
  ...
})
```

**5. 部分必需键 + 动态可选键 + 相同类型**
```js
z.intersection(
  z.object({
    requiredKey1: z.string(),
    requiredKey2: z.coerce.number()
  }),
  z.record(z.string(), z.string())
)
```

---

#### 可清除对象的处理

对于可能被 JSON patch 清除的对象（`{ "op": "remove", "path": "/path/to/object" }`）：

**推荐**：
```js
z.object({ ... }).prefault({})
```

**不推荐**：
```js
z.object({ ... }).optional()
```

**原因**：`.prefault({})` 对增量更新兼容性更好

---

### 约束与验证规则

#### 容错优先原则

当接收到违反 schema 的更新时，优先使用 `z.transform` 进行修正，而非直接拒绝：

**推荐方式**（自动修正）：
```js
// 值限制在 0-100 之间
好感度: z.coerce.number().transform(value => _.clamp(value, 0, 100))

// 对象键数量限制：保留最新的 10 条记录
记忆: z.record(z.string(), z.string()).transform(obj => {
  return _(obj).entries().takeRight(10).fromPairs().value();
})
```

**不推荐**（直接拒绝）：
```js
好感度: z.number().min(0).max(100)  // 会抛出错误
```

**重要**：仅在 Explorer（用户）明确要求时才施加这些约束

---

#### 键顺序处理

当 Explorer 要求处理键的插入时间相关操作时,应使用 Lodash 的 `_(data).entries()` 方法,它几乎总是按插入顺序列出键。

**推荐方式**:
```js
// 保留最新的 10 条记录
记忆: z.record(z.string(), z.string()).transform(obj => {
  return _(obj).entries().takeRight(10).fromPairs().value();
})
```

**不推荐**:
```js
// ❌ Object.entries() 顺序不可靠
记忆: z.record(z.string(), z.string()).transform(obj => {
  const entries = Object.entries(obj);
  return Object.fromEntries(entries.slice(-10));
})
```

**使用时间戳排序**:

当需要在 `z.transform` 中根据时间对键进行排序时,应使用 `$time` 字段自动记录插入时间:

```js
// 自动为每条记录添加时间戳
记忆: z.record(
  z.string().describe('记忆ID'),
  z.object({
    内容: z.string(),
    $time: z.coerce.number().prefault(() => Date.now())
  })
).transform(obj => {
  // 按时间排序,保留最新的 10 条
  return _(obj)
    .entries()
    .sortBy(([_, v]) => v.$time)
    .takeRight(10)
    .fromPairs()
    .value();
})
```

**要点**:
- `_(data).entries()` 优先于 `Object.entries()`,能更可靠地保持插入顺序
- 使用 `$time: z.coerce.number().prefault(() => Date.now())` 自动分配时间戳
- 仅在需要额外排序逻辑时才使用 `$time` 字段

---

#### 特殊格式处理

对于特殊格式的字符串（如固定模板），优先使用 `z.templateLiteral` 而非正则或手动解析：

**推荐**：
```js
// 例如：时间格式 "HH:MM"
时间: z.templateLiteral([z.string(), ":", z.string()])
```

**不推荐**：
```js
时间: z.string().regex(/^\d{2}:\d{2}$/)
```

**注意**：这种情况较少出现，仅在确实需要时使用

---

### 默认值设置

#### 使用 prefault 而非 default

**推荐**：
```js
z.string().prefault("默认值")
```

**不推荐**：
```js
z.string().default("默认值")
```

**重要**：除非 Explorer 明确要求，否则不要设置任何默认值或施加任何约束

---

### 描述字段的使用

仅在没有字段名来解释 schema 用途时才使用 `z.describe()`，例如 `z.record` 的键类型：

**应该使用 describe**：
```js
物品栏: z.record(
  z.string().describe('物品名'),  // 键没有字段名，需要描述
  z.object({ 描述: z.string() })
)
```

**不应该使用 describe**：
```js
// ❌ 不好：字段名已经说明了用途
好感度: z.coerce.number().describe('好感度数值')

// ✅ 好：字段名已经足够清晰
好感度: z.coerce.number()
```

---

### 避免重复定义

尽可能合并相同的变量 schema，但不要为此定义额外的变量。

**重要限制**：只能在 `export const Schema = z.object({ ... })` 内部定义 schema

**可以接受**（内联合并）：
```js
export const Schema = z.object({
  角色A: z.object({ 好感度: z.coerce.number() }),
  角色B: z.object({ 好感度: z.coerce.number() })
  // 即使重复，也不额外定义变量
});
```

**不推荐**（定义额外变量）：
```js
// ❌ 不要这样做
const 角色Schema = z.object({ 好感度: z.coerce.number() });
export const Schema = z.object({
  角色A: 角色Schema,
  角色B: 角色Schema
});
```

---

## 标准输出格式

### 脚本模板

```js
import { registerMvuSchema } from 'https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js';

export const Schema = z.object({
  // 在此定义你的变量结构
  日期: z.string(),
  时间: z.string(),
  user: z.object({
    身份: z.string(),
    当前位置: z.string(),
    好感度: z.coerce.number().transform(v => _.clamp(v, -100, 100))
  }),
  // ... 其他变量
});

$(() => {
  registerMvuSchema(Schema);
})
```


---

## 示例参考

**注意**：以下示例仅供参考，实际应根据项目需求定义变量结构。

```js
import { registerMvuSchema } from 'https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js';

export const Schema = z.object({
  日期: z.string(),
  时间: z.string(),

  user: z.object({
    身份: z.string(),
    当前位置: z.string(),
    重要经历: z.string(),
    好感度: z.coerce.number().transform(v => _.clamp(v, -100, 100))
  }),

  理: z.object({
    当前位置: z.string(),
    情绪状态: z.object({
      pleasure: z.coerce.number().transform(v => _.clamp(v, -1, 1)),
      arousal: z.coerce.number().transform(v => _.clamp(v, -1, 1))
    }),
    当前所想: z.string()
  }),

  世界: z.object({
    当前事件阶段: z.coerce.number(),
    天气: z.string()
  }),

  物品栏: z.record(
    z.string().describe('物品名'),
    z.object({
      描述: z.string(),
      数量: z.coerce.number()
    })
  ).prefault({})
});

$(() => {
  registerMvuSchema(Schema);
})
```

---

## 输出要求

### 1. 主体内容

生成完整的 JavaScript 脚本文件，包含：
- 必要的 import 语句
- 完整的 Schema 定义
- 注册 schema 的初始化代码

### 2. 设计原则确认

确保生成的 schema：
- 符合幂等操作要求（`Schema.parse(Schema.parse(input))` === `Schema.parse(input)`）
- 数字类型使用 `z.coerce.number()`
- 优先使用对象（record）而非数组
- 仅在 Explorer 明确要求时添加约束和默认值
- 使用 `z.transform` 进行容错处理（如需要）
- 仅在必要时使用 `z.describe()`（如 record 的键类型）
- 不要定义额外变量，所有 schema 定义在 `export const Schema = z.object({ ... })` 内部


---

## 生成指令

生成内容后，使用 Write 工具将脚本代码保存到 `变量结构.js` 文件中。

---

## 使用说明

### 与其他模块的关系

- **模块1.1**（变量初始化）：使用此 schema 验证初始值
- **模块2**（变量更新规则）：更新规则应符合此 schema 定义
- **模块3**（变量处理指令集）：更新命令会被此 schema 验证

---

## 重要提醒

**约束和默认值**：
- **重复强调**：仅在 Explorer 明确要求时才添加验证约束
- **重复强调**：仅在 Explorer 明确要求时才设置默认值（使用 `z.prefault`）
- 优先使用 `z.transform` 进行容错处理，而非直接拒绝输入
- 当接收到违反约束的更新时，用户期望更新能产生某些效果而非完全被丢弃

**幂等性检查**：
- 生成 schema 后，确保 `Schema.parse(Schema.parse(data))` 等于 `Schema.parse(data)`
- 特别注意 `z.transform` 的使用，避免多次解析产生不同结果
