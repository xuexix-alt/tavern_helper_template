# MVU Zod 更新说明

## 概述

MVU Zod 是对原 MVU 系统的重大升级，从自定义变量管理系统升级为基于 **Zod Schema** 和 **JSON Patch (RFC 6902)** 标准的类型安全系统。本次更新从根本上解决了旧版本存在的类型安全、边界控制、复杂数据操作等核心问题。

---

## 核心问题与解决方案

### 问题 1：缺乏类型约束，AI 经常混淆数据类型

**旧版本问题**：
```yaml
# AI 可能这样操作
好感度: "50"  # 字符串而非数字
体力: "85"    # 字符串而非数字
```

AI 在更新数值型变量时，可能将数字写成字符串，导致后续计算和比较逻辑出错。

**新版本解决方案**：

使用 **Zod Schema** 定义严格的类型约束：

```javascript
// 变量结构.js
import { z } from 'zod'

const Schema = z.object({
  好感度: z.coerce.number(),  // 自动转换为数字
  体力: z.coerce.number(),
  姓名: z.string(),
  标签: z.array(z.string())
}).strict()
```

**效果**：
- 所有变量更新都会经过 Schema 验证
- `z.coerce.number()` 自动将 `"50"` 转换为 `50`
- 类型错误会被立即发现和修正

---

### 问题 2：无法约束数值范围，AI 突破边界值

**旧版本问题**：
```yaml
# 定义了好感度上限 100
好感度:
  type: number
  range: 0-100

# 但 AI 仍然可能这样操作
_.set('好感度', 150)  # 超出上限！
_.add('好感度', 60)   # 从 90 加到 150！
```

旧版本只能在 `变量更新规则.yaml` 中"建议" AI 不要超过范围，但无法强制执行。

**新版本解决方案**：

使用 **z.transform()** 在 Schema 层面强制约束：

```javascript
// 变量结构.js
import { z } from 'zod'
import _ from 'lodash'

const Schema = z.object({
  好感度: z.coerce.number()
    .transform(v => _.clamp(v, 0, 100)),  // 强制限制在 0-100

  体力: z.coerce.number()
    .transform(v => _.clamp(v, 0, 100)),

  年龄: z.coerce.number()
    .transform(v => _.clamp(v, 0, 150))
}).strict()
```

**效果**：
```javascript
// AI 操作：{ "op": "replace", "path": "/好感度", "value": 150 }
// Schema 自动修正为：好感度 = 100

// AI 操作：{ "op": "replace", "path": "/体力", "value": -20 }
// Schema 自动修正为：体力 = 0
```

无论 AI 如何操作，数值都会被自动钳制在有效范围内。

---

### 问题 3：复杂数据结构操作困难，AI 难以精确定位

**旧版本问题**：

```javascript
// 复杂的嵌套结构
{
  "角色关系": {
    "络络": {
      "亲密度": 50,
      "信任度": 30
    },
    "白夭夭": {
      "亲密度": 80,
      "信任度": 70
    }
  },
  "记忆": [
    { "时间": "2024-01", "事件": "初次相遇" },
    { "时间": "2024-02", "事件": "共同冒险" }
  ]
}

// AI 需要这样操作（不直观）
_.set('角色关系.络络.亲密度', 60)
_.insert('记忆', { "时间": "2024-03", "事件": "并肩作战" })
```

问题：
- 路径表示不统一（`.` 分隔符）
- 数组操作语义不清（insert 到哪个位置？）
- AI 容易写错嵌套路径
- 对象键名包含特殊字符时会出错

**新版本解决方案**：

采用 **JSON Patch** 标准的 **JSON Pointer** 路径格式：

```javascript
// 使用统一的 / 分隔符
[
  {
    "op": "replace",
    "path": "/角色关系/络络/亲密度",
    "value": 60
  },
  {
    "op": "add",
    "path": "/记忆/-",  // - 表示数组末尾
    "value": { "时间": "2024-03", "事件": "并肩作战" }
  },
  {
    "op": "remove",
    "path": "/记忆/0"  // 精确删除第一个元素
  }
]
```

**路径格式优势**：

| 场景 | 旧版本 | 新版本（JSON Pointer） |
|------|--------|----------------------|
| 嵌套对象 | `角色关系.络络.亲密度` | `/角色关系/络络/亲密度` |
| 数组索引 | `记忆[0].事件` | `/记忆/0/事件` |
| 数组末尾 | 不清晰 | `/记忆/-` ✅ |
| 特殊字符 | `obj.key-name` ❌ | `/obj/key-name` ✅ |

---

### 问题 4：数组和对象操作语义模糊

**旧版本问题**：

```javascript
// AI 不确定这些操作的具体行为
_.add('记忆', newItem)      // 添加到哪里？开头还是结尾？
_.insert('记忆', newItem)   // 和 add 有什么区别？
_.remove('记忆', oldItem)   // 按值删除还是按索引？
```

**新版本解决方案**：

**JSON Patch** 提供明确的操作语义：

```javascript
// 1. 添加到数组末尾
{
  "op": "add",
  "path": "/记忆/-",
  "value": "新记忆"
}

// 2. 插入到指定位置
{
  "op": "add",
  "path": "/记忆/1",  // 插入到索引 1
  "value": "插入的记忆"
}

// 3. 删除指定位置
{
  "op": "remove",
  "path": "/记忆/0"  // 删除索引 0
}

// 4. 替换指定位置
{
  "op": "replace",
  "path": "/记忆/2",
  "value": "修改后的记忆"
}
```

**对比表**：

| 操作 | 旧版本 | 新版本 JSON Patch |
|------|--------|------------------|
| 替换值 | `_.set(path, value)` | `{ "op": "replace", "path": "/x", "value": v }` ✅ |
| 数组追加 | `_.add(path, value)` 🤔 | `{ "op": "add", "path": "/arr/-", "value": v }` ✅ |
| 数组插入 | `_.insert(path, value)` 🤔 | `{ "op": "add", "path": "/arr/1", "value": v }` ✅ |
| 数组删除 | `_.remove(path, value)` 🤔 | `{ "op": "remove", "path": "/arr/0" }` ✅ |

---

### 问题 5：缺乏运行时验证，数据一致性难以保证

**旧版本问题**：

```javascript
// AI 可能生成这样的数据
{
  "角色关系": {
    "络络": {
      "亲密度": 50
      // 缺少 "信任度" 字段！
    }
  },
  "标签": "勇敢"  // 应该是数组，却是字符串！
}
```

旧版本缺乏结构验证，AI 可能遗漏必需字段或写错数据结构。

**新版本解决方案**：

**Zod Schema 的严格验证**：

```javascript
// 变量结构.js
const 角色关系Schema = z.record(
  z.object({
    亲密度: z.coerce.number(),
    信任度: z.coerce.number()  // 必需字段
  }).strict()  // 不允许额外字段
)

const Schema = z.object({
  角色关系: 角色关系Schema,
  标签: z.array(z.string())  // 必须是数组
}).strict()

// 验证时
const result = Schema.parse(data)
// ❌ 如果数据不符合，会抛出详细的错误信息
// ✅ 如果符合，返回类型安全的数据
```

**效果**：
- 每次变量更新都经过 Schema 验证
- 自动发现缺失字段、类型错误、结构错误
- 提供清晰的错误提示

---

### 问题 6：幂等性问题，重复解析可能导致数据变化

**旧版本问题**：

```javascript
// 假设有默认值逻辑
parse({ 好感度: undefined })
// 第一次解析：{ 好感度: 0 }
// 第二次解析：{ 好感度: 0 } ✅

parse({ 记忆: [] })
// 第一次解析：{ 记忆: ["默认记忆"] }
// 第二次解析：{ 记忆: ["默认记忆", "默认记忆"] } ❌
```

旧版本的默认值处理可能导致重复解析时数据累积。

**新版本解决方案**：

**Zod 的幂等性设计**：

```javascript
// 使用 .transform() 而非 .default()
const Schema = z.object({
  好感度: z.coerce.number()
    .transform(v => v || 0),  // 空值转为 0

  记忆: z.array(z.string())
    .transform(arr => arr.length > 0 ? arr : ["初始记忆"])
    // 只在数组为空时添加
}).strict()

// 幂等性保证
Schema.parse(Schema.parse(data)) === Schema.parse(data) ✅
```

**效果**：
- 重复解析不会改变数据
- 支持增量更新和多次校验
- 数据处理流程更加可预测

---

### 问题 7：使用对象而非数组，操作更加灵活

**旧版本问题**：

```javascript
// 使用数组存储角色关系
{
  "角色关系": [
    { "name": "络络", "亲密度": 50 },
    { "name": "白夭夭", "亲密度": 80 }
  ]
}

// AI 需要遍历才能找到目标
// 更新"络络"的亲密度：需要先找到索引
_.set('角色关系[0].亲密度', 60)  // 假设络络在索引 0
```

问题：
- 需要知道元素在数组中的位置
- 位置可能改变（排序、删除后）
- 查找效率低

**新版本设计建议**：

```javascript
// 使用 z.record() 定义对象结构
const Schema = z.object({
  角色关系: z.record(
    z.object({
      亲密度: z.coerce.number(),
      信任度: z.coerce.number()
    })
  )
}).strict()

// 数据结构
{
  "角色关系": {
    "络络": { "亲密度": 50, "信任度": 30 },
    "白夭夭": { "亲密度": 80, "信任度": 70 }
  }
}

// AI 直接通过键访问
{
  "op": "replace",
  "path": "/角色关系/络络/亲密度",
  "value": 60
}
```

**优势**：
- 通过键直接访问，不需要索引
- 路径更加直观：`/角色关系/络络/亲密度`
- 增删改操作更加清晰
- AI 更容易理解和操作

---

## 新版本核心优势总结

### 1. 类型安全

| 特性 | 旧版本 | 新版本 |
|------|--------|--------|
| 类型定义 | YAML 描述 | Zod Schema（强类型） |
| 类型检查 | 无 | 运行时验证 |
| 类型转换 | 手动 | `z.coerce.*` 自动转换 |
| 错误提示 | 模糊 | 精确的类型错误信息 |

### 2. 边界控制

| 特性 | 旧版本 | 新版本 |
|------|--------|--------|
| 数值范围 | 仅建议 | `z.transform()` 强制限制 |
| 结构约束 | 无 | `z.strict()` 严格模式 |
| 默认值 | 容易重复添加 | 幂等性保证 |

### 3. 操作标准化

| 特性 | 旧版本 | 新版本 |
|------|--------|--------|
| 更新格式 | 自定义 `_.set` | JSON Patch (RFC 6902) |
| 路径格式 | `.` 分隔符 | JSON Pointer `/` 分隔符 |
| 操作语义 | 模糊 | 明确（replace/add/remove） |
| 工业标准 | 否 | 是 ✅ |

### 4. 数据结构

| 特性 | 旧版本 | 新版本 |
|------|--------|--------|
| 推荐结构 | 数组 | 对象（`z.record()`） |
| 访问方式 | 索引 | 键 |
| 路径表达 | `/arr/0/name` | `/obj/key/name` ✅ |

---

## 迁移指南

### 第 1 步：编写 Zod Schema（新增）

```javascript
// 变量结构.js
import { z } from 'zod'
import _ from 'lodash'

const Schema = z.object({
  好感度: z.coerce.number()
    .transform(v => _.clamp(v, 0, 100)),

  角色关系: z.record(
    z.object({
      亲密度: z.coerce.number(),
      信任度: z.coerce.number()
    })
  ),

  记忆: z.array(z.string())
}).strict()

export default Schema
```

### 第 2 步：更新变量初始化格式

```yaml
# 旧版本（JSON5）
{
  "好感度": 0,
  "角色关系": [
    { "name": "络络", "亲密度": 50 }
  ]
}

# 新版本（YAML，基于 Schema）
好感度: 0
角色关系:
  络络:
    亲密度: 50
    信任度: 30
记忆: []
```

### 第 3 步：更新变量更新规则

```yaml
# 旧版本
好感度:
  type: number
  range: 0-100
  check: 当角色表现出喜爱时增加

# 新版本（简化，因为约束已在 Schema 中）
好感度:
  check: 当角色表现出喜爱时增加
  # type 和 range 已在 Schema 中定义
```

### 第 4 步：更新指令集输出格式

```yaml
# 旧版本
输出格式: |
  _.set('好感度', 60)
  _.add('记忆', '新记忆')

# 新版本（JSON Patch）
输出格式: |
  [
    { "op": "replace", "path": "/好感度", "value": 60 },
    { "op": "add", "path": "/记忆/-", "value": "新记忆" }
  ]
```

---

## 实战案例对比

### 案例：角色好感度系统

**场景**：络络的好感度从 90 增加到 100，但 AI 错误地设置为 120

**旧版本**：
```javascript
// AI 输出
_.set('角色关系[0].亲密度', 120)  // ❌ 超出范围

// 结果
{ "角色关系": [{ "name": "络络", "亲密度": 120 }] }  // 错误！
```

**新版本**：
```javascript
// AI 输出
{ "op": "replace", "path": "/角色关系/络络/亲密度", "value": 120 }

// Schema 自动修正
{ "角色关系": { "络络": { "亲密度": 100 } } }  // ✅ 自动限制
```

---

### 案例：复杂嵌套结构更新

**场景**：在角色的记忆数组中，删除第一条记忆，添加新记忆

**旧版本**：
```javascript
// AI 需要复杂操作
_.remove('角色.记忆[0]')  // 删除语法不清晰
_.add('角色.记忆', { 时间: '2024-03', 事件: '并肩作战' })  // 添加到哪里？
```

**新版本**：
```javascript
[
  {
    "op": "remove",
    "path": "/角色/记忆/0"  // ✅ 明确删除索引 0
  },
  {
    "op": "add",
    "path": "/角色/记忆/-",  // ✅ 明确添加到末尾
    "value": { "时间": "2024-03", "事件": "并肩作战" }
  }
]
```

---

## FAQ

### Q1: 为什么要使用 Zod 而非 JSON Schema？

**A**: Zod 提供了更好的 TypeScript 集成、更简洁的语法、更强大的 transform 能力，且能直接在 JavaScript 中使用，非常适合 CLI 工作流。

### Q2: JSON Patch 会不会让 AI 更难理解？

**A**: 恰恰相反。JSON Patch 是工业标准，路径格式（`/a/b/c`）比点分隔符（`a.b.c`）更统一，操作语义（replace/add/remove）更明确，AI 模型对标准格式的理解更准确。

### Q3: 如何处理 AI 生成了不符合 Schema 的数据？

**A**: Zod 会抛出详细的验证错误，你可以：
1. 使用 `z.coerce.*` 自动转换类型
2. 使用 `z.transform()` 修正数据
3. 在指令集中提供更清晰的示例

### Q4: 旧版本的作品需要迁移吗？

**A**: 建议迁移。新版本提供了更好的类型安全和操作清晰度。迁移步骤：
1. 根据旧的变量初始化编写 Zod Schema
2. 将 JSON5 转为 YAML 格式
3. 更新指令集的输出格式为 JSON Patch
4. 测试验证

---

## 总结

MVU Zod 通过引入 **类型安全**（Zod Schema）和 **标准化操作**（JSON Patch），从根本上解决了旧版本的核心痛点：

✅ **类型错误** → Zod 自动转换和验证
✅ **边界失控** → transform 强制约束
✅ **操作混乱** → JSON Patch 明确语义
✅ **路径复杂** → JSON Pointer 统一格式
✅ **数据不一致** → 运行时验证 + 幂等性
✅ **数组难操作** → 推荐使用对象（z.record）

这是一次面向未来的升级，为构建更复杂、更可靠的动态角色和世界系统奠定了坚实基础。
