// Auto-generated by scripts/postbuild-generate-loaders.mjs
// Loads the sibling index.html, injects its styles, and re-executes its scripts.

const __th_loaded = (globalThis.__tavern_helper_inline_loaders__ ??= new Set());
const __th_key = import.meta.url;
if (__th_loaded.has(__th_key)) {
  // Prevent double-mount if the user pastes the loader twice.
  return;
}
__th_loaded.add(__th_key);

const indexUrl = new URL('./index.html', import.meta.url);

(async () => {
  const html = await fetch(indexUrl).then(r => r.text());
  const doc = new DOMParser().parseFromString(html, 'text/html');

  // Inject styles into the real <head>.
  doc.querySelectorAll('head > style, head > link[rel="stylesheet"]').forEach(node => {
    document.head.appendChild(node);
  });

  // Inject body content (excluding scripts; we recreate them to guarantee execution).
  const scripts = Array.from(doc.body.querySelectorAll('script'));
  for (const s of scripts) s.remove();
  document.body.append(...doc.body.childNodes);

  // Re-run scripts in original order.
  for (const src of scripts) {
    const type = (src.getAttribute('type') ?? '').trim().toLowerCase();

    // Keep injected data container (and any other text/plain scripts) inert.
    if (type === 'text/plain') {
      document.body.appendChild(src);
      continue;
    }

    const s = document.createElement('script');
    if (src.hasAttribute('type')) s.setAttribute('type', src.getAttribute('type'));
    if (src.hasAttribute('nomodule')) s.setAttribute('nomodule', '');
    if (src.hasAttribute('async')) s.setAttribute('async', '');
    if (src.hasAttribute('defer')) s.setAttribute('defer', '');
    if (src.id) s.id = src.id;

    if (src.src) s.src = src.src;
    else s.textContent = src.textContent;

    document.body.appendChild(s);
  }
})().catch(err => console.error('[tavern_helper_template loader] Failed:', err));
